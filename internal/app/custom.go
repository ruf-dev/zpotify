// Code generated by RedSock CLI.
// DO EDIT, DON'T DELETE THIS FILE.

package app

import (
	"context"

	"go.redsock.ru/rerrors"
	"golang.org/x/sync/errgroup"

	"go.zpotify.ru/zpotify/internal/background"
	"go.zpotify.ru/zpotify/internal/background/sessions_gc"
	tgApi "go.zpotify.ru/zpotify/internal/clients/telegram"
	"go.zpotify.ru/zpotify/internal/middleware"
	"go.zpotify.ru/zpotify/internal/service"
	"go.zpotify.ru/zpotify/internal/storage"
	"go.zpotify.ru/zpotify/internal/storage/pg"
	"go.zpotify.ru/zpotify/internal/transport/telegram"
	"go.zpotify.ru/zpotify/internal/transport/wapi"
	"go.zpotify.ru/zpotify/internal/transport/zpotify_api_impl"
	"go.zpotify.ru/zpotify/pkg/docs"
	"go.zpotify.ru/zpotify/pkg/zpotify_api"
)

type Custom struct {
	storage     storage.Storage
	tgApiClient tgApi.TgApiClient

	service service.Service

	grpcImpl         *zpotify_api_impl.Impl
	telegram         *telegram.Server
	backgroundWorker *background.Worker
}

func (c *Custom) Init(a *App) (err error) {
	c.storage = pg.NewStorage(a.Postgres)

	c.tgApiClient = tgApi.NewTgApiClient(a.Telegram.Bot.Token)

	c.service = service.New(c.tgApiClient, c.storage)

	c.backgroundWorker = background.New(sessions_gc.New(c.storage))

	c.telegram, err = telegram.NewServer(a.Telegram, c.service)
	if err != nil {
		return rerrors.Wrap(err, "error creating telegram server")
	}

	c.grpcImpl = zpotify_api_impl.New(c.service)

	a.ServerMaster.AddServerOption(
		middleware.WithInterceptWithAuth(
			c.service,
			middleware.WithIgnoredPathAuthOption(
				zpotify_api.UserAPI_Auth_FullMethodName,
				zpotify_api.UserAPI_RefreshToken_FullMethodName),
		),
	)

	a.ServerMaster.AddImplementation(c.grpcImpl)
	a.ServerMaster.AddHttpHandler(docs.Swagger())
	a.ServerMaster.AddHttpHandler("/wapi/", wapi.New(c.service.AudioService()))
	return nil
}

// Start - launch custom handlers
// Even if you won't use it keep it for proper work
func (c *Custom) Start(ctx context.Context) error {

	eg, ctx := errgroup.WithContext(ctx)

	eg.Go(func() error {
		return c.telegram.Start(ctx)
	})

	eg.Go(func() error {
		return c.backgroundWorker.Start()
	})

	err := eg.Wait()
	if err != nil {
		return rerrors.Wrap(err)
	}

	return nil
}

// Stop - gracefully stop custom handlers
// Even if you won't use it keep it for proper work
func (c *Custom) Stop() error {
	eg := errgroup.Group{}

	eg.Go(func() error {
		return c.telegram.Stop()
	})

	eg.Go(func() error {
		return c.backgroundWorker.Stop()
	})

	err := eg.Wait()
	if err != nil {
		return rerrors.Wrap(err)
	}
	return nil
}
